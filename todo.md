- Lab 1 Map Reduce
	- basic idea
		- one coordinator multiple workers on same machine
		- workers communicate with coordinator via RPC
		- workers
			- ask coordinator for task
			- read tasks input from one or more files
			- execute task
			- write task output to one or more files
			- if worker hasn't completed tasks in 10s give task to different worker
	- rules
		- map phase
			- divide intermediate keys into buckets for nReduce reduce tasks
			- each mapper creates nReduce intermediate files for reduce tasks
			- intermediate Map output files in current directory where workers can read them as input to reduce tasks
		- reduce phase
			- output of the X'th reduce tasks in the file mr-out-X
				- this file contains one line per reduce function output
				- watch out for correct format
		- main
			- expects mr/coordinator.go to implement Done() method to return true when MR job completed
			- when job done all workers should exit
	- hints

- Todo:
	- [] use encoding/json package, map key/value pairs to json
	- [] review intermediate map output file names mr-X-Y (where X is the Map task number, and Y is the reduce task number.)
 	- The map part of your worker can use the ihash(key) function (in worker.go) to pick the reduce task for a given key.
	- [] need to wait for all maps to complete before beginning reduce
	- [] on all map tasks complete -> turn all tasks back to unprocessed but reduce phase
	- [] line 44 coordinator: check if all tasks are "processed" then change state if so
	- [] implement coordinator 10s wait for worker to complete else give to other worker

